<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gemini on firebirdテクテクテクブログ</title><link>https://firebird-techtalktech.com/tags/gemini/</link><description>Recent content in Gemini on firebirdテクテクテクブログ</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>トミー</copyright><lastBuildDate>Sat, 04 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://firebird-techtalktech.com/tags/gemini/index.xml" rel="self" type="application/rss+xml"/><item><title>Conversational Analytics API パブリックプレビュー概要紹介</title><link>https://firebird-techtalktech.com/post/conversational-analytics-api-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E6%A6%82%E8%A6%81%E7%B4%B9%E4%BB%8B/</link><pubDate>Sat, 04 Oct 2025 00:00:00 +0000</pubDate><guid>https://firebird-techtalktech.com/post/conversational-analytics-api-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E6%A6%82%E8%A6%81%E7%B4%B9%E4%BB%8B/</guid><description>&lt;p&gt;承知いたしました。 「GitHub FlowとTrunk-Based開発の違い」について、10分程度で読める技術記事風にまとめました。
GitHub Flow vs. Trunk-Based開発：あなたのチームに最適なワークフローは？
ソフトウェア開発において、Gitのワークフローはチームの生産性とコードの品質を左右する重要な要素です。世の中には様々なワークフローが存在しますが、今回は特に頻繁に比較される「GitHub Flow」と「Trunk-Based Development」に焦点を当て、その違いと、それぞれのメリット・デメリットを解説します。&lt;/p&gt;
&lt;p&gt;開発スタイルを分ける2つのアプローチ
まず、両者の根本的な違いは「メインブランチへのマージ頻度」にあります。
Trunk-Based Development（トランクベース開発）
このアプローチの最大の特徴は、すべての開発者がmain（またはtrunk）という単一のメインブランチに、ごく短い期間で頻繁にコミット（マージ）することです。
特徴:
フィーチャーは非常に短い期間のブランチ（数時間～1日程度）で開発されます。
開発者は、自身の変更を迅速にmainブランチに統合します。
常にmainブランチが「デプロイ可能」な状態に保たれるよう、厳格なテストとCI/CDパイプラインが不可欠です。
メリット:
継続的な統合: 変更が常に統合されるため、マージコンフリクトが最小限に抑えられます。
迅速なフィードバック: 問題が発生した場合でも、原因特定が容易で、迅速に修正できます。
リリースサイクルの短縮: いつでもデプロイできるため、市場への投入が早まります。
GitHub Flow
GitHubが提唱したこのワークフローは、**プルリクエスト（PR）**を軸にした、ブランチベースの開発モデルです。
特徴:
新機能やバグ修正ごとに、mainブランチから新しいフィーチャーブランチを作成します。
作業が完了したらプルリクエストを作成し、コードレビューを経てからmainブランチにマージします。
多くの場合、develop、staging、productionといった複数の環境ブランチを設けて、段階的に変更をテスト・デプロイします。
メリット:
厳格なレビュープロセス: マージ前に必ずレビューが行われるため、コードの品質を保ちやすいです。
リスクの隔離: 複数のフィーチャーを統合するdevelopブランチや、本番環境の最終確認を行うstagingブランチを設けることで、段階的にリスクを減らせます。
柔軟なリリース制御: 安定したproductionブランチを維持しつつ、必要に応じてstagingブランチの内容をリリースできます。&lt;/p&gt;
&lt;p&gt;あなたのチームが採用しているのは？
冒頭の質問に戻ると、あなたのチームのdevelop → staging → productionというマージフローは、典型的なGitHub Flowの運用形態です。
これは「まとめて作業を実施する」というよりは、「段階的なテストとデプロイ」を重視しているため、このようなフローになっています。
develop: 複数のフィーチャーを統合し、初期の結合テストを行う場。
staging: 本番環境に近い状態で、最終的なユーザー受け入れテスト（UAT）や性能テストを行う場。
production: ライブ環境。このブランチへのマージは、いよいよ本番リリースを意味します。
この多段階のプロセスは、特にユーザーへの影響が大きいアプリケーションや、大規模なチームでの開発において、リスクを最小限に抑えるための合理的な選択と言えます。
まとめ&lt;/p&gt;
&lt;p&gt;Trunk-Based Development
GitHub Flow
マージ頻度
非常に高い（毎日複数回）
比較的低い（PRごとに都度）
主な目的
継続的な統合、迅速なデリバリー
リスク管理、厳格なレビュー
適したチーム
小規模～中規模、高い自動化レベルのチーム
大規模、複雑なアプリケーションを開発するチーム
主な課題
高度なCI/CDパイプラインが必要
マージ作業の複雑化、リリースが遅れる可能性
どちらのワークフローも、それぞれメリットとデメリットがあります。あなたのチームが何を最も重視するかによって、最適な選択は異なります。重要なのは、チーム全体が共通のワークフローを理解し、そのルールに従って一貫した開発を進めることです。
承知いたしました。 「GitHub FlowとTrunk-Based開発の違い」について、10分程度で読める技術記事風にまとめました。
GitHub Flow vs. Trunk-Based開発：あなたのチームに最適なワークフローは？
ソフトウェア開発において、Gitのワークフローはチームの生産性とコードの品質を左右する重要な要素です。世の中には様々なワークフローが存在しますが、今回は特に頻繁に比較される「GitHub Flow」と「Trunk-Based Development」に焦点を当て、その違いと、それぞれのメリット・デメリットを解説します。&lt;/p&gt;
&lt;p&gt;開発スタイルを分ける2つのアプローチ
まず、両者の根本的な違いは「メインブランチへのマージ頻度」にあります。
Trunk-Based Development（トランクベース開発）
このアプローチの最大の特徴は、すべての開発者がmain（またはtrunk）という単一のメインブランチに、ごく短い期間で頻繁にコミット（マージ）することです。
特徴:
フィーチャーは非常に短い期間のブランチ（数時間～1日程度）で開発されます。
開発者は、自身の変更を迅速にmainブランチに統合します。
常にmainブランチが「デプロイ可能」な状態に保たれるよう、厳格なテストとCI/CDパイプラインが不可欠です。
メリット:
継続的な統合: 変更が常に統合されるため、マージコンフリクトが最小限に抑えられます。
迅速なフィードバック: 問題が発生した場合でも、原因特定が容易で、迅速に修正できます。
リリースサイクルの短縮: いつでもデプロイできるため、市場への投入が早まります。
GitHub Flow
GitHubが提唱したこのワークフローは、**プルリクエスト（PR）**を軸にした、ブランチベースの開発モデルです。
特徴:
新機能やバグ修正ごとに、mainブランチから新しいフィーチャーブランチを作成します。
作業が完了したらプルリクエストを作成し、コードレビューを経てからmainブランチにマージします。
多くの場合、develop、staging、productionといった複数の環境ブランチを設けて、段階的に変更をテスト・デプロイします。
メリット:
厳格なレビュープロセス: マージ前に必ずレビューが行われるため、コードの品質を保ちやすいです。
リスクの隔離: 複数のフィーチャーを統合するdevelopブランチや、本番環境の最終確認を行うstagingブランチを設けることで、段階的にリスクを減らせます。
柔軟なリリース制御: 安定したproductionブランチを維持しつつ、必要に応じてstagingブランチの内容をリリースできます。&lt;/p&gt;
&lt;p&gt;あなたのチームが採用しているのは？
冒頭の質問に戻ると、あなたのチームのdevelop → staging → productionというマージフローは、典型的なGitHub Flowの運用形態です。
これは「まとめて作業を実施する」というよりは、「段階的なテストとデプロイ」を重視しているため、このようなフローになっています。
develop: 複数のフィーチャーを統合し、初期の結合テストを行う場。
staging: 本番環境に近い状態で、最終的なユーザー受け入れテスト（UAT）や性能テストを行う場。
production: ライブ環境。このブランチへのマージは、いよいよ本番リリースを意味します。
この多段階のプロセスは、特にユーザーへの影響が大きいアプリケーションや、大規模なチームでの開発において、リスクを最小限に抑えるための合理的な選択と言えます。
まとめ&lt;/p&gt;
&lt;p&gt;Trunk-Based Development
GitHub Flow
マージ頻度
非常に高い（毎日複数回）
比較的低い（PRごとに都度）
主な目的
継続的な統合、迅速なデリバリー
リスク管理、厳格なレビュー
適したチーム
小規模～中規模、高い自動化レベルのチーム
大規模、複雑なアプリケーションを開発するチーム
主な課題
高度なCI/CDパイプラインが必要
マージ作業の複雑化、リリースが遅れる可能性
どちらのワークフローも、それぞれメリットとデメリットがあります。あなたのチームが何を最も重視するかによって、最適な選択は異なります。重要なのは、チーム全体が共通のワークフローを理解し、そのルールに従って一貫した開発を進めることです。&lt;/p&gt;</description></item><item><title>Conversational Analytics API パブリックプレビュー概要紹介</title><link>https://firebird-techtalktech.com/post/conversational-analytics-api-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E6%A6%82%E8%A6%81%E7%B4%B9%E4%BB%8B/</link><pubDate>Sat, 04 Oct 2025 00:00:00 +0000</pubDate><guid>https://firebird-techtalktech.com/post/conversational-analytics-api-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E6%A6%82%E8%A6%81%E7%B4%B9%E4%BB%8B/</guid><description>&lt;p&gt;title: &amp;ldquo;サブモジュール経由で発生するソースコード漏えいの落とし穴と対策&amp;rdquo;
description: &amp;ldquo;Git submodule のリモート誤設定や push 振る舞いが引き起こす情報漏えいの実例と、即時ロックから恒久対策までの実践ガイド。&amp;rdquo;
date: 2025-09-24T09:00:00+09:00
slug: git-submodule-source-leak
tags: [&amp;ldquo;Git&amp;rdquo;, &amp;ldquo;GitHub&amp;rdquo;, &amp;ldquo;Security&amp;rdquo;, &amp;ldquo;Submodule&amp;rdquo;, &amp;ldquo;DevSecOps&amp;rdquo;]
categories: [&amp;ldquo;テック&amp;rdquo;]
draft: false
TL;DR: サブモジュールは独立した Git リポジトリです。サブモジュール配下で origin を「自分が書き込める Public リポジトリ」に向けたまま push すると、その中身は即時に公開されます。さらに親リポジトリの push.recurseSubmodules や pre-push フックの実装次第では、親で git push しただけでサブモジュールが push され、意図せず漏えいが起こり得ます。&lt;/p&gt;
&lt;p&gt;背景
モノレポやサイト構築（Hugo など）で外部テーマ／ライブラリを submodule として取り込むのは一般的です。しかし、サブモジュールは“別リポジトリ”そのものであり、配下で git remote set-url origin &amp;hellip; を変えれば、単独で push できます。この性質と、親の push 時の挙動（push.recurseSubmodules、pre-push フック、CI スクリプト）が組み合わさると、気づかないうちに第三者の Public リポジトリへコードが押し出される危険があります。&lt;/p&gt;
&lt;p&gt;よくある漏えいシナリオ
flowchart TB
A[開発者が親リポで作業] &amp;ndash;&amp;gt; B[サブモジュール内で修正]
B &amp;ndash;&amp;gt; C[サブモジュール内の origin を自分の Public リポに変更]
C &amp;ndash;&amp;gt; D{親で git push}
D &amp;ndash;&amp;gt;|on-demand/フックが push| E[サブモジュールも push]
E &amp;ndash;&amp;gt; F[Public リポに中身が公開]&lt;/p&gt;
&lt;p&gt;トリガーA: サブモジュール内で origin を書き込み可能な Public リポジトリに設定&lt;/p&gt;
&lt;p&gt;トリガーB: 親で git push した際に&lt;/p&gt;
&lt;p&gt;push.recurseSubmodules=on-demand で「参照コミットがリモートに無ければサブモジュールも push」&lt;/p&gt;
&lt;p&gt;あるいは pre-push フックが git submodule foreach などで push を試みる&lt;/p&gt;
&lt;p&gt;すぐできる被害最小化（即時ロック）
親リポジトリでサブモジュール push を止める:&lt;/p&gt;
&lt;h1 id="親リポで-サブモジュールを-push-対象にしない"&gt;親リポで: サブモジュールを push 対象にしない
&lt;/h1&gt;&lt;p&gt;git config push.recurseSubmodules no&lt;/p&gt;
&lt;h1 id="push-のドライラン癖付け"&gt;push のドライラン癖付け
&lt;/h1&gt;&lt;p&gt;git push &amp;ndash;dry-run origin main&lt;/p&gt;
&lt;p&gt;各サブモジュールで push を物理的に無効化（安全策）:&lt;/p&gt;
&lt;h1 id="ルートで実行-すべてのサブモジュールの-pushurl-を無効化"&gt;ルートで実行: すべてのサブモジュールの pushURL を無効化
&lt;/h1&gt;&lt;h1 id="fetch-url-はそのまま"&gt;(fetch URL はそのまま)
&lt;/h1&gt;&lt;p&gt;git config -f .gitmodules &amp;ndash;get-regexp &amp;lsquo;^submodule..*.path$&amp;rsquo; |
while read -r _ path; do
echo &amp;ldquo;Locking $path&amp;rdquo;
git -C &amp;ldquo;$path&amp;rdquo; remote set-url &amp;ndash;push origin DISABLED || true
hookdir=&amp;quot;$(git -C &amp;ldquo;$path&amp;rdquo; rev-parse &amp;ndash;git-dir)/hooks&amp;quot;
mkdir -p &amp;ldquo;$hookdir&amp;rdquo;
cat &amp;gt; &amp;ldquo;$hookdir/pre-push&amp;rdquo; &amp;laquo;&amp;lsquo;SH&amp;rsquo;
#!/bin/sh
echo &amp;ldquo;ERROR: Pushing from this submodule is disabled.&amp;rdquo; &amp;gt;&amp;amp;2
exit 1
SH
chmod +x &amp;ldquo;$hookdir/pre-push&amp;rdquo;
done&lt;/p&gt;
&lt;p&gt;これでサブモジュール直下での git push は常に失敗し、誤操作やフック経由の push も止まります。&lt;/p&gt;
&lt;p&gt;恒久対策（レイヤ別）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;設定レイヤ（Git）
親リポ: git config push.recurseSubmodules no をデフォルトに&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;サブモジュール URL の整合性: git submodule sync &amp;ndash;recursive&lt;/p&gt;
&lt;p&gt;危険 URL のブロック（親の pre-push フック）：&lt;/p&gt;
&lt;h1 id="githookspre-push-親リポ"&gt;.git/hooks/pre-push （親リポ）
&lt;/h1&gt;&lt;p&gt;#!/bin/sh
set -e
url=$(git remote get-url &amp;ndash;push origin 2&amp;gt;/dev/null || echo &amp;ldquo;&amp;rdquo;)
case &amp;ldquo;$url&amp;rdquo; in
&lt;a class="link" href="mailto:git@github.com" &gt;git@github.com&lt;/a&gt;:your-org/&lt;em&gt;|https://github.com/your-org/&lt;/em&gt;) ;;
*) echo &amp;ldquo;ERROR: Blocked push to non-allowed remote: $url&amp;rdquo; &amp;gt;&amp;amp;2; exit 1;;
esac&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;リポジトリレイヤ（GitHub 側）
Private 化（フォークやミラーも）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Protected Branch（強制 push 禁止、PR 必須、レビュー必須）&lt;/p&gt;
&lt;p&gt;Secret Scanning / Push Protection を有効化&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;
&lt;p&gt;CI レイヤ（検知）
GitHub Actionsで誤 push を検知・ブロック:
name: guard-visibility
on: [push]
jobs:
check:
runs-on: ubuntu-latest
steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name: Fail if repo is public
if: ${{ !github.event.repository.private }}
run: |
echo &amp;ldquo;Repository is public. Aborting.&amp;rdquo; &amp;gt;&amp;amp;2
exit 1&lt;/li&gt;
&lt;li&gt;uses: actions/checkout@v4&lt;/li&gt;
&lt;li&gt;name: Allowlist push target
run: |
url=$(git remote get-url &amp;ndash;push origin || true)
case &amp;ldquo;$url&amp;rdquo; in
&lt;a class="link" href="mailto:git@github.com" &gt;git@github.com&lt;/a&gt;:your-org/&lt;em&gt;|https://github.com/your-org/&lt;/em&gt;) ;;
*) echo &amp;ldquo;Blocked remote: $url&amp;rdquo; &amp;gt;&amp;amp;2; exit 1;;
esac&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;運用レイヤ（人の習慣）
git remote -v／git remote get-url &amp;ndash;push origin をpush 前に確認&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;git push &amp;ndash;dry-run を毎回実行&lt;/p&gt;
&lt;p&gt;サブモジュールに変更を加える場合は 必ずフォークを Private で作る → .gitmodules をフォーク URL に変更 → PR&lt;/p&gt;
&lt;p&gt;兆候と検知ポイント
git push 時に 予期しないリモート URL がログに出る（例: 第三者のテーマ作者のリポ）&lt;/p&gt;
&lt;p&gt;pre-push / CI ログに サブモジュールでの push 成功の痕跡&lt;/p&gt;
&lt;p&gt;GitHub の 監査ログ／Contributors に意図しない push 履歴&lt;/p&gt;
&lt;p&gt;調査ワンライナー:&lt;/p&gt;
&lt;h1 id="親の-push-先"&gt;親の push 先
&lt;/h1&gt;&lt;p&gt;git remote -v | sed -n &amp;lsquo;/origin/p&amp;rsquo;&lt;/p&gt;
&lt;h1 id="すべてのサブモジュールの-fetchpush-先一覧"&gt;すべてのサブモジュールの fetch/push 先一覧
&lt;/h1&gt;&lt;p&gt;git config -f .gitmodules &amp;ndash;get-regexp &amp;lsquo;^submodule..*.path$&amp;rsquo; |
while read -r _ path; do
echo &amp;ldquo;[$path]&amp;rdquo;; git -C &amp;ldquo;$path&amp;rdquo; remote -v; echo
done&lt;/p&gt;
&lt;p&gt;よくある質問（FAQ）
Q. リポジトリが Public か Private かで差はある？
A. 公開可否と書き込み権限は別です。Public でも あなたに書き込み権限がなければ push できず、403 で止まります。逆に Public で書き込める先に向いていれば、即座に誰でも読める状態になります。
Q. &amp;ndash;no-verify を付けても止まらないのは？
A. &amp;ndash;no-verify は フックの実行抑止だけです。origin の向き先が第三者リポであれば素通りしてしまうため、URL ガード（pre-push 内の URL 判定）と pushURL の無効化 を合わせ技で使います。
Q. サブモジュールの “detached HEAD” は問題？
A. サブモジュールとしては 正常です。問題は どこに push され得るか です。&lt;/p&gt;
&lt;p&gt;ベストプラクティス：Read‑Only 運用 + PR フロー
結論: 外部のサブモジュールは read‑only に保ち、変更が必要になったら「別途 clone（またはフォーク）→ 修正 → 上流へ PR」。親リポには 参照コミットだけ を更新します。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Read‑Only の基本設定（親とサブモジュール）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="親-サブモジュールを-push-対象にしない"&gt;親: サブモジュールを push 対象にしない
&lt;/h1&gt;&lt;p&gt;git config push.recurseSubmodules no&lt;/p&gt;
&lt;h1 id="サブモジュール側-push-を物理的に無効化誤操作防止"&gt;サブモジュール側: push を物理的に無効化（誤操作防止）
&lt;/h1&gt;&lt;p&gt;git -C &lt;submodule-path&gt; remote set-url &amp;ndash;push origin DISABLED
cat &amp;gt; &amp;ldquo;$(git -C &lt;submodule-path&gt; rev-parse &amp;ndash;git-dir)/hooks/pre-push&amp;rdquo; &amp;laquo;&amp;lsquo;SH&amp;rsquo;
#!/bin/sh
echo &amp;ldquo;ERROR: Pushing from this submodule is disabled.&amp;rdquo; &amp;gt;&amp;amp;2
exit 1
SH
chmod +x &amp;ldquo;$(git -C &lt;submodule-path&gt; rev-parse &amp;ndash;git-dir)/hooks/pre-push&amp;rdquo;&lt;/p&gt;
&lt;h1 id="url-の整合を保つgitmodules--ローカルへ反映"&gt;URL の整合を保つ（.gitmodules → ローカルへ反映）
&lt;/h1&gt;&lt;p&gt;git submodule sync &amp;ndash;recursive&lt;/p&gt;
&lt;p&gt;.gitmodules は原典（upstream）URLのまま。サブモジュール直下では push しない運用にします。
2) 変更が必要になったときの手順（別途 clone → PR）&lt;/p&gt;
&lt;h1 id="1-自分の作業ディレクトリで上流のリポジトリをフォーク-or-直接-clone"&gt;1) 自分の作業ディレクトリで、上流のリポジトリをフォーク or 直接 clone
&lt;/h1&gt;&lt;h1 id="-機微が混じる可能性があるならフォークは-private-推奨"&gt;※ 機微が混じる可能性があるならフォークは Private 推奨
&lt;/h1&gt;&lt;h1 id="例-フォークを-clone"&gt;例: フォークを clone
&lt;/h1&gt;&lt;p&gt;git clone &lt;a class="link" href="mailto:git@github.com" &gt;git@github.com&lt;/a&gt;:&lt;you&gt;/&lt;forked-repo&gt;.git
cd &lt;forked-repo&gt;&lt;/p&gt;
&lt;p&gt;git remote add upstream &lt;a class="link" href="https://github.com/" target="_blank" rel="noopener"
&gt;https://github.com/&lt;/a&gt;&lt;upstream-owner&gt;/&lt;upstream-repo&gt;.git&lt;/p&gt;
&lt;p&gt;git checkout -b fix/your-change&lt;/p&gt;
&lt;h1 id="-変更-"&gt;&amp;hellip; 変更 &amp;hellip;
&lt;/h1&gt;&lt;p&gt;git commit -s -m &amp;ldquo;fix: &lt;summary&gt;&amp;rdquo;
git push -u origin HEAD&lt;/p&gt;
&lt;h1 id="github-で-originupstream-への-pr-を作成"&gt;GitHub で origin→upstream への PR を作成
&lt;/h1&gt;&lt;p&gt;PR が upstream にマージ された後、親リポで参照コミットを更新します：
cd /path/to/parent&lt;/p&gt;
&lt;h1 id="サブモジュールで最新を取得"&gt;サブモジュールで最新を取得
&lt;/h1&gt;&lt;p&gt;git -C &lt;submodule-path&gt; fetch &amp;ndash;tags &amp;ndash;all&lt;/p&gt;
&lt;h1 id="目的のコミットまたはタグへ移動"&gt;目的のコミット(またはタグ)へ移動
&lt;/h1&gt;&lt;p&gt;git -C &lt;submodule-path&gt; checkout &lt;merge-commit-or-tag&gt;&lt;/p&gt;
&lt;h1 id="親にポインタ更新を記録"&gt;親にポインタ更新を記録
&lt;/h1&gt;&lt;p&gt;git add &lt;submodule-path&gt;
git commit -m &amp;ldquo;chore(submodule): bump &lt;name&gt; to &amp;lt;sha/tag&amp;gt;&amp;rdquo;
git push&lt;/p&gt;
&lt;p&gt;※ .gitmodules に branch = main を設定していれば、git submodule update &amp;ndash;remote &lt;path&gt; で「そのブランチの最新へ」上げることも可能です（明示運用推奨）。
3) どうしても PR を待てない場合（代替案）
オーバーレイ: 親の layouts/ / assets/ 等で上書き（Hugo などで有効）。&lt;/p&gt;
&lt;p&gt;パッチ適用: 親レポに patches/ を置き、git apply/git am を CI/ローカルで当てる。サブモジュール自体は upstream のまま。&lt;/p&gt;
&lt;p&gt;いずれの方法でも、サブモジュール配下からの push は不要です。&lt;/p&gt;
&lt;p&gt;まとめ
サブモジュールは独立リポ。origin が Public かつ書き込み可であれば即漏えい。&lt;/p&gt;
&lt;p&gt;親の push.recurseSubmodules=no、サブモジュール pushURL 無効化、pre-push の URL Allowlist で 多層防御 を。&lt;/p&gt;
&lt;p&gt;CI と運用ルールで最後の見張りを置いて、ヒューマンエラーを吸収する。&lt;/p&gt;
&lt;p&gt;付録: チェックリスト（配布用）
親: git remote -v で push 先を確認&lt;/p&gt;
&lt;p&gt;親: git config push.recurseSubmodules が no&lt;/p&gt;
&lt;p&gt;サブモジュール: remote -v で pushURL が DISABLED（または Private）&lt;/p&gt;
&lt;p&gt;親 .git/hooks/pre-push に URL Allowlist 実装&lt;/p&gt;
&lt;p&gt;GitHub: Private + Protected Branch + Secret Scanning&lt;/p&gt;
&lt;p&gt;CI: 可視性チェック + リモート Allowlist&lt;/p&gt;
&lt;p&gt;運用: git push &amp;ndash;dry-run を習慣化&lt;/p&gt;
&lt;p&gt;本記事のサンプルスクリプトは 自己責任でお試しください。組織のポリシーに合わせて、許可ドメインやブランチ名、CI 条件を調整してください。&lt;/p&gt;</description></item><item><title>Conversational Analytics API パブリックプレビュー概要紹介</title><link>https://firebird-techtalktech.com/post/conversational-analytics-api-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E6%A6%82%E8%A6%81%E7%B4%B9%E4%BB%8B/</link><pubDate>Sat, 04 Oct 2025 00:00:00 +0000</pubDate><guid>https://firebird-techtalktech.com/post/conversational-analytics-api-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E6%A6%82%E8%A6%81%E7%B4%B9%E4%BB%8B/</guid><description>&lt;hr&gt;
&lt;h2 id="draft-false"&gt;title: &amp;ldquo;GitHub Pagesに独自ドメインを割り当てる手順とDNSの基礎（レジストラ/レジストリ/NSの関係）&amp;rdquo;
date: 2025-09-24T00:00:00+09:00
slug: github-pages-domain-dns-basics
summary: &amp;ldquo;GitHub Pages に独自ドメインを割り当てるための最短手順と、レジストラ・レジストリ・権威DNS・NSレコードなどの用語関係を図解で整理。初心者でも“どこで何を設定するか”がわかるようにまとめました。&amp;rdquo;
author: &amp;ldquo;anonymous&amp;rdquo;
categories: [&amp;ldquo;インフラ&amp;rdquo;]
tags: [&amp;ldquo;DNS&amp;rdquo;,&amp;ldquo;ドメイン&amp;rdquo;,&amp;ldquo;GitHub Pages&amp;rdquo;,&amp;ldquo;レジストラ&amp;rdquo;,&amp;ldquo;レジストリ&amp;rdquo;,&amp;ldquo;NSレコード&amp;rdquo;]
draft: false
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;この記事は匿名の個人メモです。&lt;/strong&gt; 例として &lt;code&gt;example.com&lt;/code&gt; / &lt;code&gt;www.example.com&lt;/code&gt; と &lt;code&gt;username.github.io&lt;/code&gt; を使用します。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id="0-まず結論最短手順"&gt;0. まず結論（最短手順）
&lt;/h1&gt;&lt;p&gt;GitHub Pages に独自ドメインをつなぐ最小セットはこれだけ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;（リポジトリ → &lt;em&gt;Settings → Pages&lt;/em&gt;）で &lt;strong&gt;Custom domain&lt;/strong&gt; に &lt;code&gt;example.com&lt;/code&gt; を保存（&lt;code&gt;CNAME&lt;/code&gt; ファイルが自動作成される場合あり）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**DNS（権威DNSの管理画面）**でレコードを追加：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Apex（&lt;code&gt;example.com&lt;/code&gt;）&lt;/strong&gt; … &lt;strong&gt;A&lt;/strong&gt; を4件、&lt;strong&gt;AAAA&lt;/strong&gt; を4件（IPv6対応時）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;A 185.199.108.153
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;A 185.199.109.153
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;A 185.199.110.153
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;A 185.199.111.153
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;AAAA 2606:50c0:8000::153
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;AAAA 2606:50c0:8001::153
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;AAAA 2606:50c0:8002::153
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;AAAA 2606:50c0:8003
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;em&gt;ApexにCNAMEは置けません。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;www（&lt;code&gt;www.example.com&lt;/code&gt;）&lt;/strong&gt; … &lt;strong&gt;CNAME&lt;/strong&gt; を &lt;code&gt;username.github.io&lt;/code&gt; に向ける（末尾ドット不要）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTPS を有効化&lt;/strong&gt;（GitHub Pages の &lt;em&gt;Enforce HTTPS&lt;/em&gt; をON）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;→ 反映後、&lt;code&gt;example.com&lt;/code&gt; / &lt;code&gt;www.example.com&lt;/code&gt; のどちらでも Pages サイトに到達します。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="1-用語の整理誰が何をしている"&gt;1. 用語の整理：誰が何をしている？
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Registrant（登録者）&lt;/strong&gt; … あなた。ドメインの所有者。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Registrar（レジストラ）&lt;/strong&gt; … ドメインの“販売・窓口”。例：お名前.com, Route 53 Domains, Cloudflare Registrar など。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Registry（レジストリ）&lt;/strong&gt; … TLD を運用する主体。例：&lt;code&gt;.com&lt;/code&gt; の Verisign、&lt;code&gt;.jp&lt;/code&gt; の JPRS。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Authoritative DNS（権威DNS）&lt;/strong&gt; … そのドメインの&lt;strong&gt;最終的な答え&lt;/strong&gt;（A/AAAA/CNAME/MX/TXT…）を返すDNS。例：&lt;code&gt;01–04.dnsv.jp&lt;/code&gt;（お名前.com DNS）、Cloudflare DNS、Route 53 Hosted Zone など。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Recursive Resolver（再帰DNS）&lt;/strong&gt; … 8.8.8.8 / 1.1.1.1 など。クライアントの代わりに辿って答えをキャッシュしてくれる。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NSレコード（Name Server）&lt;/strong&gt; … 「このドメインの&lt;strong&gt;権威DNSはどれか&lt;/strong&gt;」を親ゾーンに教える“委任”情報。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DSレコード&lt;/strong&gt; … DNSSEC を使う場合、親ゾーンに登録する検証用情報。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ポイント：&lt;strong&gt;レジストラ&lt;/strong&gt;は必ずしも自社DNSを提供するわけではありませんが、多くは&lt;strong&gt;権威DNSサービスも提供&lt;/strong&gt;しています（お名前.comの &lt;code&gt;dnsv.jp&lt;/code&gt; など）。一方、Cloudflare や Route 53 は「レジストラ機能」も「権威DNS」も提供可能です。&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id="2-名前解決の全体像ざっくり図解"&gt;2. 名前解決の全体像（ざっくり図解）
&lt;/h1&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ブラウザ/OS → 再帰DNS
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ├─ ルート(.) … 「.comの権威NSはどこ？」
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ├─ .com（レジストリ） … 「example.comの権威NSは ns1.example-dns.tld など」
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ├─ ns*.example-dns.tld（権威DNS） … 「A/AAAA/CNAME など最終回答」
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; └─ 返ってきた複数IPのうち1つへ接続（失敗時は他IPへフォールバック）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NSレコード&lt;/strong&gt;は「どこに聞くか」を指す&lt;strong&gt;案内板&lt;/strong&gt;。A/AAAA/CNAMEといった&lt;strong&gt;中身の答え&lt;/strong&gt;は&lt;strong&gt;権威DNS&lt;/strong&gt;が持っています。&lt;/li&gt;
&lt;li&gt;複数のAレコードを返した場合、&lt;strong&gt;どのIPに接続するかはクライアント側&lt;/strong&gt;（OS/ブラウザ）の実装次第（順番に試す・並行接続・失敗時切替など）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id="3-github-pages--独自ドメイン具体手順"&gt;3. GitHub Pages × 独自ドメイン：具体手順
&lt;/h1&gt;&lt;h2 id="31-github-側の設定"&gt;3.1 GitHub 側の設定
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;リポジトリ → &lt;strong&gt;Settings → Pages&lt;/strong&gt; → &lt;strong&gt;Custom domain&lt;/strong&gt; に &lt;code&gt;example.com&lt;/code&gt; を保存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ブランチ公開の場合、ルートに &lt;code&gt;CNAME&lt;/code&gt; ファイル（中身は &lt;code&gt;example.com&lt;/code&gt; 1行）が自動コミットされるケースがあります。&lt;/li&gt;
&lt;li&gt;Actions 等で発行する場合は &lt;code&gt;CNAME&lt;/code&gt; ファイルをビルド成果物に含めない運用も可（Pages の設定でドメインを登録してあればOK）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Enforce HTTPS&lt;/strong&gt; をON（Let’s Encrypt による証明書が自動発行）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="32-dns-側の設定権威dnsの画面"&gt;3.2 DNS 側の設定（権威DNSの画面）
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Apex（&lt;code&gt;example.com&lt;/code&gt;）&lt;/strong&gt;：A を4件、可能なら AAAA も4件（上記一覧を転記）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;www（&lt;code&gt;www.example.com&lt;/code&gt;）&lt;/strong&gt;：CNAME → &lt;code&gt;username.github.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ApexにCNAMEは不可&lt;/em&gt;。もし DNS が &lt;strong&gt;ALIAS / ANAME&lt;/strong&gt; をサポートしているなら、それを &lt;code&gt;username.github.io&lt;/code&gt; に向けてもOK（提供事業者による）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="33-反映確認dig-例"&gt;3.3 反映確認（dig 例）
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 委任（親 .com の見解）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;dig NS example.com @a.gtld-servers.net +short
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 実レコード（権威DNSからの答え）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;dig example.com A +short
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;dig example.com AAAA +short
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;dig www.example.com CNAME +short
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h1 id="4-よくある疑問と注意点"&gt;4. よくある疑問と注意点
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Q1. Aレコードは1つでも動く？&lt;/strong&gt;
→ 動くことはありますが、&lt;strong&gt;4つ全部&lt;/strong&gt;（&lt;code&gt;185.199.108.153–111.153&lt;/code&gt;）を入れるのが実務推奨。冗長化・フォールバックに効きます。IPv6 環境なら AAAA も4つを追加。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2. “浸透待ち”って何？&lt;/strong&gt;
→ 誰かが配っているわけではなく、&lt;strong&gt;再帰DNSのキャッシュTTLが更新されていくのを待つ&lt;/strong&gt;こと。数分〜数時間、場合によっては24–48時間程度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3. &lt;code&gt;www&lt;/code&gt; にも A/AAAA を入れていい？&lt;/strong&gt;
→ &lt;strong&gt;推奨しません。&lt;/strong&gt; &lt;code&gt;www&lt;/code&gt; は &lt;strong&gt;CNAME → &lt;code&gt;username.github.io&lt;/code&gt;&lt;/strong&gt; のみ。A/AAAA を併置すると整合性が崩れることがあります。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q4. Apex に CNAME を置けないのはなぜ？&lt;/strong&gt;
→ DNS 仕様上、ゾーンの頂点（Apex）に CNAME を置くと他レコードと両立できません。代替は &lt;strong&gt;A/AAAA&lt;/strong&gt; か、DNS 事業者の &lt;strong&gt;ALIAS/ANAME&lt;/strong&gt; です。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q5. NS はどこで決まる？&lt;/strong&gt;
→ &lt;strong&gt;レジストラの管理画面&lt;/strong&gt;で設定し、&lt;strong&gt;レジストリ&lt;/strong&gt;（例：&lt;code&gt;.com&lt;/code&gt;＝Verisign）へ登録されます。親ゾーンの NS が「委任先＝あなたの権威DNS」を指します。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q6. メール（MX/TXT/SPF/DMARC）は？&lt;/strong&gt;
→ 既に運用中なら &lt;strong&gt;NS 切り替え前に新DNSへ全レコードを複製&lt;/strong&gt;しておくこと（切替直後のメール不達を防止）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q7. CAA は必要？&lt;/strong&gt;
→ 任意ですが、Let’s Encrypt を明示するなら Apex に以下を1件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;CAA 0 issue &amp;#34;letsencrypt.org&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h1 id="5-役割の違いをもう一度誤解しがちなポイント"&gt;5. 役割の違いをもう一度（誤解しがちなポイント）
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;レジストラ（例：お名前.com/Route 53/Cloudflare）&lt;/strong&gt; … レジストリに &lt;strong&gt;NS（＋DS）&lt;/strong&gt; を登録する“窓口”。&lt;strong&gt;自社DNSを提供することも多いが必須ではない&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;レジストリ（例：&lt;code&gt;.com&lt;/code&gt;＝Verisign）&lt;/strong&gt; … 親ゾーンに &lt;strong&gt;NS（委任）&lt;/strong&gt; を掲載。&lt;strong&gt;A/AAAA/CNAME等は保持しない&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;権威DNS（例：dnsv.jp / Cloudflare DNS / Route 53 Hosted Zone）&lt;/strong&gt; … &lt;strong&gt;A/AAAA/CNAME/MX/TXT…の最終回答&lt;/strong&gt;を返すサーバー群。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;組み合わせは原則自由（例：レジストラ＝お名前.com、権威DNS＝Cloudflare）。現実的には「他社レジストラのドメインでもDNSだけ受ける」かどうかは&lt;strong&gt;各事業者の提供ポリシー&lt;/strong&gt;に依存します。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id="6-仕上げチェックリストコピペ用"&gt;6. 仕上げチェックリスト（コピペ用）
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; GitHub → Pages → &lt;strong&gt;Custom domain&lt;/strong&gt; に &lt;code&gt;example.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; &lt;strong&gt;Enforce HTTPS&lt;/strong&gt; ON&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; Apex に &lt;strong&gt;A ×4&lt;/strong&gt;（185.199.108.153〜111.153）&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; Apex に &lt;strong&gt;AAAA ×4&lt;/strong&gt;（&lt;code&gt;2606:50c0:8000::153&lt;/code&gt;〜&lt;code&gt;::8003&lt;/code&gt;）※対応時&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; &lt;code&gt;www&lt;/code&gt; に &lt;strong&gt;CNAME → &lt;code&gt;username.github.io&lt;/code&gt;&lt;/strong&gt;（A/AAAAは置かない）&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; （任意）CAA &lt;code&gt;letsencrypt.org&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled="" type="checkbox"&gt; &lt;code&gt;dig&lt;/code&gt; で &lt;strong&gt;NS / A / AAAA / CNAME&lt;/strong&gt; を確認&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;以上。この記事の手順をそのまま置換すれば、Hugo/静的サイトでも数分で独自ドメイン化できます。必要に応じて &lt;code&gt;example.com&lt;/code&gt; / &lt;code&gt;username.github.io&lt;/code&gt; をあなたの値に置き換えてください。&lt;/p&gt;</description></item><item><title>Conversational Analytics API パブリックプレビュー概要紹介</title><link>https://firebird-techtalktech.com/post/conversational-analytics-api-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E6%A6%82%E8%A6%81%E7%B4%B9%E4%BB%8B/</link><pubDate>Sat, 04 Oct 2025 00:00:00 +0000</pubDate><guid>https://firebird-techtalktech.com/post/conversational-analytics-api-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%97%E3%83%AC%E3%83%93%E3%83%A5%E3%83%BC%E6%A6%82%E8%A6%81%E7%B4%B9%E4%BB%8B/</guid><description>&lt;p&gt;Google Cloud Next ’25 で発表された &lt;strong&gt;Conversational Analytics API&lt;/strong&gt; が、2025年8月末から &lt;strong&gt;パブリックプレビュー&lt;/strong&gt; として提供開始されました。&lt;br&gt;
BigQuery や Looker / Looker Studio 向けに &lt;strong&gt;データエージェントを自動生成&lt;/strong&gt; し、自然言語での分析を可能にする強力な機能です。&lt;br&gt;
日本語での情報がまだ少ないため、この記事では概要を整理してご紹介します。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="conversational-analytics-apiとは"&gt;Conversational Analytics APIとは？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Google Cloudの自然言語クエリエンジンをAPIとして利用可能にするもの&lt;/strong&gt; です。&lt;br&gt;
LookerやBigQuery Data Canvasで使われている自然言語分析の仕組みを、API経由で自分のアプリケーションにも組み込めるようになります。&lt;/p&gt;
&lt;p&gt;イメージとしては：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BigQuery&lt;/strong&gt; のテーブルに対して自然言語で質問&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Looker / Looker Studio&lt;/strong&gt; の可視化を自然言語で操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL生成・実行 → 可視化 → 回答生成&lt;/strong&gt; を自動処理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が可能になります。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="利用イメージ"&gt;利用イメージ
&lt;/h2&gt;&lt;p&gt;基本的な流れは次の通りです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;データエージェントの作成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conversationの作成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自然言語での分析実行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例として、BigQueryのデータに「空港の総数が多い上位5州の棒グラフを作成してください」と質問すると：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エージェントが &lt;strong&gt;テーブル定義を取得&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;自動で &lt;strong&gt;SQLを生成・実行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;グラフを作成&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最終的な回答を返却&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;と進みます。SQLを自分で書かなくても、自然言語で分析できるのは非常に魅力的です。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="adkとの使い分け"&gt;ADKとの使い分け
&lt;/h2&gt;&lt;p&gt;Google Cloudには &lt;strong&gt;ADK (Agent Development Kit)&lt;/strong&gt; もあり、こちらでもBigQueryやLookerに対するAIエージェントを作成できます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Conversational Analytics API&lt;/strong&gt;&lt;br&gt;
→ Googleが用意した自然言語分析エージェントをそのまま利用可能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ADK&lt;/strong&gt;&lt;br&gt;
→ 自分でプロンプト設計や制御ができる高カスタマイズ型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使い分けとしては、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手軽に自然言語分析を始めたい → Conversational Analytics API&lt;/li&gt;
&lt;li&gt;より細かい制御や独自仕様を組み込みたい → ADK&lt;br&gt;
という形になりそうです。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;なお、ADKの &lt;code&gt;ask_data_insights&lt;/code&gt; ツールは Conversational Analytics API をベースとしており、組み合わせて使うことも可能です。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="個人的に推しポイント"&gt;個人的に推しポイント
&lt;/h2&gt;&lt;p&gt;実際に試してみて「これは良い」と思った点を3つ挙げます。&lt;/p&gt;
&lt;h3 id="1-データ指定がシンプル"&gt;1. データ指定がシンプル
&lt;/h3&gt;&lt;p&gt;BigQueryテーブルを以下のように指定するだけでエージェントを作成可能です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;bigquery_table_reference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;geminidataanalytics&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BigQueryTableReference&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;bigquery_table_reference&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;project_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;my_project_id&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;bigquery_table_reference&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dataset_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;my_dataset_id&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;bigquery_table_reference&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;table_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;my_table_id&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;LookerやLooker Studioでも同様の設定が可能。
とりあえず対象テーブルを渡すだけで自然言語分析ができる手軽さが魅力です。&lt;/p&gt;
&lt;h3 id="2-ビジネス用語をsystem_instructionに渡せる"&gt;2. ビジネス用語をsystem_instructionに渡せる
&lt;/h3&gt;&lt;p&gt;自然言語での分析では、ユーザーの言葉とテーブル定義を正しく対応づけるのが重要です。
このAPIでは system_instruction にYAMLでビジネス用語やmeasureを定義でき、精度を向上させられる設計になっています。&lt;/p&gt;
&lt;h3 id="3-bigqueryクエリのスキャン量制限"&gt;3. BigQueryクエリのスキャン量制限
&lt;/h3&gt;&lt;p&gt;big_query_max_billed_bytes を設定することで、エージェントが実行するクエリのスキャン量を制御できます。
BigQueryのオンデマンド課金を使っている場合に「誤って巨大クエリを実行される」リスクを防げるのは非常に安心です。&lt;/p&gt;
&lt;h2 id="まとめ"&gt;まとめ
&lt;/h2&gt;&lt;p&gt;BigQueryやLookerのデータを 自然言語で分析可能というのはとても便利そうです。
データエージェントを簡単に構築できる
ADKとも組み合わせ可能
やはり、特に、SQLを書かずにBigQueryを操作できる点は多くのユーザーにとって魅力的だと思います。&lt;/p&gt;</description></item><item><title>Qiitaトレンド総まとめ2025 - AI時代のエンジニアリング最前線</title><link>https://firebird-techtalktech.com/post/qiita-trending-digest-2025/</link><pubDate>Mon, 29 Sep 2025 12:00:00 +0900</pubDate><guid>https://firebird-techtalktech.com/post/qiita-trending-digest-2025/</guid><description>&lt;h2 id="-2025年9月qiitaトレンドから見る技術動向"&gt;📊 2025年9月Qiitaトレンドから見る技術動向
&lt;/h2&gt;&lt;p&gt;2025年9月のQiita人気記事を分析すると、**AI・機械学習関連が全体の52.5%**を占め、エンジニアリングの世界がAI中心に急速に変化していることが明確になりました。本記事では、40の人気記事から見えてくる技術トレンドを体系的に整理し、今押さえるべき技術要素をまとめます。&lt;/p&gt;
&lt;h2 id="-ai機械学習の最新動向"&gt;🤖 AI・機械学習の最新動向
&lt;/h2&gt;&lt;h3 id="1-プロンプトエンジニアリングの民主化"&gt;1. プロンプトエンジニアリングの民主化
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;最も注目を集めた記事&lt;/strong&gt;: 「プロンプトエンジニアリング超入門」（126 likes）&lt;/p&gt;
&lt;p&gt;Midjourneyを使った画像生成において、プロンプトエンジニアリングが一般エンジニアの必須スキルとして定着。特に以下のポイントが重要視されています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;構造化プロンプト&lt;/strong&gt;: 主題、スタイル、ネガティブプロンプトの3層構造&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反復的改善&lt;/strong&gt;: 生成結果を見ながらプロンプトを調整する手法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;言語の壁を越える&lt;/strong&gt;: 英語プロンプトの効果的な構築方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-google-gemininano-bananaの実用化"&gt;2. Google Gemini「Nano Banana」の実用化
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;話題の中心&lt;/strong&gt;: 不動産写真の家具消去、UI モックアップ生成（53 likes）&lt;/p&gt;
&lt;p&gt;Geminiの軽量版「Nano Banana」が実用段階に入り、具体的な活用事例が急増：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不動産業界&lt;/strong&gt;: 物件写真から家具を自動消去し、空室状態を再現&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UI/UXデザイン&lt;/strong&gt;: モバイルアプリのモックアップ自動生成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;議事録自動化&lt;/strong&gt;: 音声からの文字起こしと要約生成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-ai駆動開発の新パラダイム"&gt;3. AI駆動開発の新パラダイム
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;最高評価記事&lt;/strong&gt;: 「Vibe CodingからDrive Codingへ」（129 likes）&lt;/p&gt;
&lt;p&gt;従来のロジカルなコーディングから、AI との対話による「欲動的」コーディングへの移行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-markdown" data-lang="markdown"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;従来: 仕様 → 設計 → 実装 → テスト
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;AI時代: アイデア → AI対話 → プロトタイプ → 改善ループ
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;キーコンセプト&lt;/strong&gt;: 「Context Is All You Need」（41 likes）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AIへの指示はコンテキストが全て&lt;/li&gt;
&lt;li&gt;明確な背景説明が良い結果を生む&lt;/li&gt;
&lt;li&gt;プロンプトの質が開発効率を左右&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-開発ツールフレームワークの進化"&gt;💻 開発ツール・フレームワークの進化
&lt;/h2&gt;&lt;h3 id="1-microsoft-copilot-の革新的機能"&gt;1. Microsoft Copilot の革新的機能
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Excel Copilot関数の可能性&lt;/strong&gt;（複数記事で言及）&lt;/p&gt;
&lt;p&gt;ExcelにCopilot関数が登場し、スプレッドシートの概念を根本から変革：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;=COPILOT(&amp;#34;売上データから来月の予測値を計算&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;=COPILOT(&amp;#34;このデータの異常値を検出して理由を説明&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Dataverseインデックスの進化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自然言語でのデータベース操作&lt;/li&gt;
&lt;li&gt;複雑なクエリの自動生成&lt;/li&gt;
&lt;li&gt;ビジネスロジックの自動実装&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-aiコードアシスタント三つ巴の戦い"&gt;2. AIコードアシスタント三つ巴の戦い
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;徹底比較&lt;/strong&gt;: Cursor vs Replit vs GitHub Copilot&lt;/p&gt;
&lt;p&gt;各ツールの特徴が明確化：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ツール&lt;/th&gt;
&lt;th&gt;強み&lt;/th&gt;
&lt;th&gt;適用場面&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Cursor&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;コンテキスト理解力&lt;/td&gt;
&lt;td&gt;大規模リファクタリング&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Replit&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;即座の実行環境&lt;/td&gt;
&lt;td&gt;プロトタイピング&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;GitHub Copilot&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;VSCode統合&lt;/td&gt;
&lt;td&gt;日常的なコーディング&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="3-openai-codex-の再評価"&gt;3. OpenAI Codex の再評価
&lt;/h3&gt;&lt;p&gt;「今さらながらOpenAI Codex」という記事が話題に。ChatGPT人気の陰で見過ごされていたCodexの実力が再認識：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IDE統合による seamless な開発体験&lt;/li&gt;
&lt;li&gt;コード特化型AIの精度の高さ&lt;/li&gt;
&lt;li&gt;ローカルLLMとの連携可能性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-プログラミング言語トレンド"&gt;🐹 プログラミング言語トレンド
&lt;/h2&gt;&lt;h3 id="go言語クリーンアーキテクチャ"&gt;Go言語＋クリーンアーキテクチャ
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;連載人気記事&lt;/strong&gt;: 「Goに入門して、ついでにクリーンアーキテクチャに入門」&lt;/p&gt;
&lt;p&gt;Go言語採用の新しい波：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;マイクロサービスとの相性&lt;/strong&gt;: 軽量・高速な特性が評価&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;クリーンアーキテクチャ適用&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ドメイン層の明確な分離&lt;/li&gt;
&lt;li&gt;テスタビリティの向上&lt;/li&gt;
&lt;li&gt;依存性注入の実践&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;実装パターン&lt;/strong&gt;:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// UseCaseインターフェース定義&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;UserUseCase&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;GetUser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;CreateUser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;error&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Repository パターンの適用&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;UserRepository&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;FindByID&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;User&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;Save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;User&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;error&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="-人気記事から見える3つのトレンド"&gt;📈 人気記事から見える3つのトレンド
&lt;/h2&gt;&lt;h3 id="トレンド1-ai活用の実用フェーズ突入"&gt;トレンド1: AI活用の実用フェーズ突入
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;理論から実践へのシフト&lt;/li&gt;
&lt;li&gt;具体的な業務課題解決事例の増加&lt;/li&gt;
&lt;li&gt;ROIを意識した導入事例&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="トレンド2-開発プロセスのai統合"&gt;トレンド2: 開発プロセスのAI統合
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;コーディングからデバッグまで全工程でAI活用&lt;/li&gt;
&lt;li&gt;人間の役割は「指示」と「検証」へシフト&lt;/li&gt;
&lt;li&gt;クリエイティビティと判断力が差別化要因に&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="トレンド3-基礎技術の再評価"&gt;トレンド3: 基礎技術の再評価
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Go言語のような「堅実な」技術への回帰&lt;/li&gt;
&lt;li&gt;アーキテクチャパターンの重要性再認識&lt;/li&gt;
&lt;li&gt;AI時代だからこそ基礎が大切&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-エンジニアが今すぐ始めるべき3つのアクション"&gt;🎯 エンジニアが今すぐ始めるべき3つのアクション
&lt;/h2&gt;&lt;h3 id="1-プロンプトエンジニアリングの習得"&gt;1. プロンプトエンジニアリングの習得
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Midjourney、ChatGPT、Geminiで日常的に練習&lt;/li&gt;
&lt;li&gt;構造化プロンプトの型を身につける&lt;/li&gt;
&lt;li&gt;英語プロンプトの基本パターンをマスター&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-aiツールの積極的活用"&gt;2. AIツールの積極的活用
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Excel Copilot関数で業務効率化&lt;/li&gt;
&lt;li&gt;Cursor/Copilotでコーディング速度向上&lt;/li&gt;
&lt;li&gt;Gemini Nano Bananaで画像処理自動化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="3-基礎技術の強化"&gt;3. 基礎技術の強化
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Go言語でクリーンアーキテクチャを実践&lt;/li&gt;
&lt;li&gt;設計パターンの理解を深める&lt;/li&gt;
&lt;li&gt;AI が苦手な領域（アーキテクチャ設計、要件定義）のスキルを磨く&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="-今後の展望"&gt;🔮 今後の展望
&lt;/h2&gt;&lt;p&gt;Qiitaの人気記事動向から、以下の流れが加速すると予測されます：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;AI ネイティブ開発&lt;/strong&gt;: AIなしでは開発が成立しない時代へ&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ノーコード/ローコードの本格化&lt;/strong&gt;: Copilot関数のような自然言語プログラミング&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;エンジニアの役割変化&lt;/strong&gt;: 実装者から設計者・検証者へ&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="まとめ"&gt;まとめ
&lt;/h2&gt;&lt;p&gt;2025年9月のQiitaトレンドは、&lt;strong&gt;AI技術の実用化元年&lt;/strong&gt;を強く印象づけるものでした。単なる実験段階を超え、実際の業務で成果を上げる事例が続出。一方で、Go言語とクリーンアーキテクチャへの注目は、AI時代だからこそ基礎が重要であることを示しています。&lt;/p&gt;
&lt;p&gt;エンジニアとして生き残るためには、&lt;strong&gt;AIを活用しつつ、AIには代替できない価値&lt;/strong&gt;を提供することが鍵となるでしょう。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-参考記事まとめ"&gt;📚 参考記事まとめ
&lt;/h3&gt;&lt;p&gt;本記事は2025年9月のQiita人気記事40本の分析に基づいています。個別の詳細については、&lt;a class="link" href="https://firebird-techtalktech.com/tags/qiita/" target="_blank" rel="noopener"
&gt;Qiitaタグページ&lt;/a&gt;から各記事をご参照ください。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;関連タグ&lt;/strong&gt;: #AI #機械学習 #Midjourney #Gemini #Copilot #Go #クリーンアーキテクチャ #プロンプトエンジニアリング&lt;/p&gt;</description></item></channel></rss>